<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>物理運動 統合グラフジェネレーター</title>
    <!-- Tailwind CSSを読み込み -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js と annotation plugin を読み込み -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0/dist/chartjs-plugin-annotation.min.js"></script>
    <!-- MathJax (LaTeX) を読み込み -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* フォント設定 */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* 入力欄の共通スタイル */
        .param-input {
            width: 80px;
            padding: 8px;
            text-align: center;
            background-color: #f3f4f6;
            border: 2px solid #d1d5db;
            border-radius: 0.5rem;
            transition: all 0.2s;
        }
        .dark .param-input {
            background-color: #374151;
            border-color: #4b5563;
            color: #f9fafb;
        }
        .param-input:focus {
            outline: none;
            --tw-ring-color: #4f46e5;
            box-shadow: 0 0 0 2px var(--tw-ring-color);
            border-color: #4f46e5;
        }
        /* ラベルの共通スタイル */
        .param-label {
            font-size: 1.125rem;
            font-weight: 500;
            width: 40px;
            text-align: right;
        }
        /* アクティブなボタンのスタイル */
        .btn-active {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
            z-index: 10;
        }
        /* 非アクティブなボタンのスタイル */
        .btn-inactive {
            background-color: #e5e7eb; /* gray-200 */
            color: #374151; /* gray-700 */
        }
        .dark .btn-inactive {
            background-color: #4b5563; /* dark:bg-gray-600 */
            color: #d1d5db; /* dark:text-gray-300 */
        }
        /* 公式表示エリアのスタイル */
        .formula-box {
            font-size: 1.1rem; /* text-lg */
            padding: 1rem; /* p-4 */
            background-color: #f9fafb; /* bg-gray-50 */
            border-radius: 0.75rem; /* rounded-xl */
            border: 1px solid #e5e7eb; /* border-gray-200 */
        }
        .dark .formula-box {
            background-color: #1f2937; /* dark:bg-gray-800 */
            border-color: #374151; /* dark:border-gray-700 */
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 flex flex-col items-center min-h-screen p-4">

    <div class="w-full max-w-7xl mx-auto bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 md:p-8">
        <h1 id="main-title" class="text-2xl md:text-3xl font-bold text-center text-indigo-600 dark:text-indigo-400 mb-4">
            物理運動グラフ
        </h1>

        <!-- モード切り替えボタン -->
        <div class="flex justify-center mb-6">
            <div class="flex border-2 border-gray-300 dark:border-gray-600 rounded-lg text-xs sm:text-sm md:text-base flex-wrap">
                <button id="btnFreeFall" class="py-2 px-2 md:px-3 rounded-l-md transition-colors duration-300">自由落下</button>
                <button id="btnVerticalThrowDown" class="py-2 px-2 md:px-3 transition-colors duration-300 border-l border-gray-300 dark:border-gray-600">投げ下ろし</button>
                <button id="btnVerticalThrowUp" class="py-2 px-2 md:px-3 transition-colors duration-300 border-l border-gray-300 dark:border-gray-600">投げ上げ</button>
                <button id="btnHorizontalProjectile" class="py-2 px-2 md:px-3 transition-colors duration-300 border-l border-gray-300 dark:border-gray-600">水平投射</button>
                <button id="btnProjectile" class="py-2 px-2 md:px-3 transition-colors duration-300 border-l border-gray-300 dark:border-gray-600">斜方投射</button>
                <button id="btnAcceleration" class="py-2 px-2 md:px-3 transition-colors duration-300 border-l border-r border-gray-300 dark:border-gray-600">加速度</button>
                <button id="btnUniform" class="py-2 px-2 md:px-3 rounded-r-md transition-colors duration-300">等加速度</button>
            </div>
        </div>

        <!-- 操作パネル -->
        <div id="control-panel" class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8 bg-gray-50 dark:bg-gray-700 p-6 rounded-xl">
            <!-- パラメータ設定 -->
            <div id="params-container">
                <h2 class="text-xl font-semibold mb-4 text-center">パラメータ設定</h2>
                <div class="space-y-4">
                    <div id="gravity-container" class="flex items-center justify-center gap-4">
                        <label for="gravity" class="param-label">g:</label>
                        <input type="number" id="gravity" value="9.8" step="0.1" class="param-input">
                        <span>m/s²</span>
                    </div>
                    <div id="acceleration-container-uniform" class="flex items-center justify-center gap-4 hidden">
                        <label for="acceleration-uniform" class="param-label">a:</label>
                        <input type="number" id="acceleration-uniform" value="2.0" step="0.1" class="param-input">
                        <span>m/s²</span>
                    </div>
                    <div id="initialVelocity-container" class="flex items-center justify-center gap-4">
                        <label for="initialVelocity" class="param-label">v₀:</label>
                        <input type="number" id="initialVelocity" value="0" step="0.1" class="param-input">
                        <span>m/s</span>
                    </div>
                     <div id="angle-container" class="flex items-center justify-center gap-4 hidden">
                        <label for="angle" class="param-label">θ:</label>
                        <input type="number" id="angle" value="45" step="1" class="param-input">
                        <span>°</span>
                    </div>
                     <div id="maxTime-container" class="flex items-center justify-center gap-4">
                        <label for="maxTime" class="param-label">t_max:</label>
                        <input type="number" id="maxTime" value="5" step="0.1" min="1" class="param-input">
                        <span>s</span>
                    </div>
                </div>
            </div>
             <!-- 加速度モード専用のパラメータ設定 -->
            <div id="acceleration-params-container" class="hidden">
                 <h2 class="text-xl font-semibold mb-4 text-center">区間設定</h2>
                 <div id="acceleration-points" class="space-y-2 max-h-48 overflow-y-auto pr-2">
                     <!-- JavaScriptで動的にポイントが追加されます -->
                 </div>
                 <div class="flex justify-center gap-4 mt-4">
                     <button id="add-point-btn" class="bg-indigo-500 text-white px-4 py-2 rounded-lg hover:bg-indigo-600 transition">区間を追加</button>
                     <button id="remove-point-btn" class="bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition">最後の区間を削除</button>
                 </div>
            </div>

            <!-- 現在値の確認 -->
            <div>
                <h2 class="text-xl font-semibold mb-4 text-center">現在値の確認</h2>
                <div class="space-y-4">
                    <div class="flex items-center justify-center gap-4">
                        <label for="timeSlider" class="param-label">t:</label>
                        <input type="range" id="timeSlider" min="0" max="5" step="0.1" value="0" class="w-40 md:w-48">
                        <span id="timeValue" class="w-16 text-left">0.0 s</span>
                    </div>
                    <div id="position-container" class="flex items-center justify-center gap-4">
                        <span id="position-label" class="param-label">y:</span>
                        <span id="positionValue" class="param-input bg-white dark:bg-gray-800">0.00</span>
                        <span>m</span>
                    </div>
                    <div id="velocity-container" class="flex items-center justify-center gap-4">
                        <span class="param-label">v:</span>
                        <span id="velocityValue" class="param-input bg-white dark:bg-gray-800">0.00</span>
                        <span>m/s</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 公式表示エリア -->
        <div class="mb-8">
            <h2 class="text-xl font-semibold mb-4 text-center">公式</h2>
            <div id="formula-display" class="formula-box text-center">
                <!-- ここに選択されたモードの公式がJavaScriptによって挿入されます -->
            </div>
        </div>

        <!-- グラフのコンテナ -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded-xl"><canvas id="graph1"></canvas></div>
            <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded-xl"><canvas id="graph2"></canvas></div>
            <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded-xl"><canvas id="graph3"></canvas></div>
        </div>
    </div>

    <script>
        // グローバル変数
        let currentMode = 'freeFall';
        let graph1Instance, graph2Instance, graph3Instance;
        const timeStep = 0.05;

        // HTML要素の取得
        const elements = {
            mainTitle: document.getElementById('main-title'),
            buttons: {
                freeFall: document.getElementById('btnFreeFall'),
                verticalThrowDown: document.getElementById('btnVerticalThrowDown'),
                verticalThrowUp: document.getElementById('btnVerticalThrowUp'),
                horizontalProjectile: document.getElementById('btnHorizontalProjectile'),
                projectile: document.getElementById('btnProjectile'),
                acceleration: document.getElementById('btnAcceleration'),
                uniform: document.getElementById('btnUniform'),
            },
            containers: {
                controlPanel: document.getElementById('control-panel'),
                params: document.getElementById('params-container'),
                accelerationParams: document.getElementById('acceleration-params-container'),
                gravity: document.getElementById('gravity-container'),
                accelerationUniform: document.getElementById('acceleration-container-uniform'),
                angle: document.getElementById('angle-container'),
                position: document.getElementById('position-container'),
                velocity: document.getElementById('velocity-container'),
            },
            inputs: {
                gravity: document.getElementById('gravity'),
                accelerationUniform: document.getElementById('acceleration-uniform'),
                initialVelocity: document.getElementById('initialVelocity'),
                angle: document.getElementById('angle'),
                maxTime: document.getElementById('maxTime'),
                timeSlider: document.getElementById('timeSlider'),
            },
            accelerationPoints: document.getElementById('acceleration-points'),
            addPointBtn: document.getElementById('add-point-btn'),
            removePointBtn: document.getElementById('remove-point-btn'),
            formulaDisplay: document.getElementById('formula-display'),
            contexts: {
                graph1: document.getElementById('graph1').getContext('2d'),
                graph2: document.getElementById('graph2').getContext('2d'),
                graph3: document.getElementById('graph3').getContext('2d'),
            }
        };
        
        const formulas = {
            freeFall: `$$v = gt$$ $$y = \\frac{1}{2}gt^2$$ <br> $$v^2 = 2gy$$`,
            verticalThrowDown: `$$v = v_0 + gt$$ $$y = v_0t + \\frac{1}{2}gt^2$$ <br> $$v^2 - v_0^2 = 2gy$$`,
            verticalThrowUp: `$$v = v_0 - gt$$ $$y = v_0t - \\frac{1}{2}gt^2$$ <br> $$v^2 - v_0^2 = -2gy$$`,
            horizontalProjectile: `水平: $$x = v_0t$$ 垂直: $$y = \\frac{1}{2}gt^2$$ <br> 軌道: $$y = \\frac{g}{2v_0^2}x^2$$`,
            projectile: `水平: $$x = (v_0 \\cos\\theta)t$$ 垂直: $$y = (v_0 \\sin\\theta)t - \\frac{1}{2}gt^2$$ <br> 軌道: $$y = (\\tan\\theta)x - \\frac{g}{2v_0^2\\cos^2\\theta}x^2$$`,
            acceleration: `$$a = \\frac{v_2 - v_1}{t_2 - t_1} = \\frac{\\Delta v}{\\Delta t}$$`,
            uniform: `$$v = v_0 + at$$ $$x = v_0t + \\frac{1}{2}at^2$$ <br> $$v^2 - v_0^2 = 2ax$$`
        };

        // モードを切り替える関数
        function setMode(mode) {
            currentMode = mode;
            Object.values(elements.buttons).forEach(btn => btn.classList.remove('btn-active', 'btn-inactive'));
            Object.values(elements.buttons).forEach((btn) => {
                const buttonMode = Object.keys(elements.buttons).find(key => elements.buttons[key] === btn);
                btn.classList.add(buttonMode === mode ? 'btn-active' : 'btn-inactive');
            });

            elements.formulaDisplay.innerHTML = formulas[mode];
            MathJax.typesetPromise([elements.formulaDisplay]);

            // UI表示の切り替え
            const isAccelMode = mode === 'acceleration';
            elements.containers.params.style.display = isAccelMode ? 'none' : 'block';
            elements.containers.accelerationParams.style.display = isAccelMode ? 'block' : 'none';
            elements.containers.controlPanel.classList.toggle('md:grid-cols-2', !isAccelMode);
            elements.containers.controlPanel.classList.toggle('md:grid-cols-1', isAccelMode);
            if(isAccelMode) elements.containers.controlPanel.classList.add('grid-cols-1');


            // UIの表示をリセット
            elements.containers.position.innerHTML = `<span id="position-label" class="param-label">y:</span><span id="positionValue" class="param-input bg-white dark:bg-gray-800">0.00</span><span>m</span>`;
            elements.containers.velocity.innerHTML = `<span class="param-label">v:</span><span id="velocityValue" class="param-input bg-white dark:bg-gray-800">0.00</span><span>m/s</span>`;
            
            elements.containers.gravity.style.display = 'none';
            elements.containers.accelerationUniform.style.display = 'none';
            elements.containers.angle.style.display = 'none';

            if (mode === 'horizontalProjectile' || mode === 'projectile') {
                elements.mainTitle.textContent = mode === 'horizontalProjectile' ? '水平投射' : '斜方投射';
                elements.containers.gravity.style.display = 'flex';
                if (elements.inputs.initialVelocity.value == 0) elements.inputs.initialVelocity.value = 20;
                if (mode === 'projectile') elements.containers.angle.style.display = 'flex';
                elements.containers.position.innerHTML = `<span class="param-label">x:</span><span id="positionX" class="param-input bg-white dark:bg-gray-800">0.00</span><span>m</span> <span class="param-label">y:</span><span id="positionY" class="param-input bg-white dark:bg-gray-800">0.00</span><span>m</span>`;
                elements.containers.velocity.innerHTML = `<span class="param-label">vₓ:</span><span id="velocityX" class="param-input bg-white dark:bg-gray-800">0.00</span><span>m/s</span> <span class="param-label">vᵧ:</span><span id="velocityY" class="param-input bg-white dark:bg-gray-800">0.00</span><span>m/s</span>`;
            } else if (mode === 'freeFall' || mode === 'verticalThrowDown' || mode === 'verticalThrowUp') {
                elements.containers.gravity.style.display = 'flex';
                document.getElementById('position-label').textContent = 'y:';
                if (mode === 'freeFall') {
                    elements.mainTitle.textContent = '自由落下運動';
                    elements.inputs.initialVelocity.value = 0;
                } else if (mode === 'verticalThrowDown') {
                    elements.mainTitle.textContent = '鉛直投げ下ろし';
                    if (elements.inputs.initialVelocity.value == 0) elements.inputs.initialVelocity.value = 5;
                } else { // verticalThrowUp
                    elements.mainTitle.textContent = '鉛直投げ上げ';
                    if (elements.inputs.initialVelocity.value <= 0) elements.inputs.initialVelocity.value = 20;
                }
            } else if (mode === 'uniform') {
                 elements.mainTitle.textContent = '等加速度運動';
                 elements.containers.accelerationUniform.style.display = 'flex';
                 document.getElementById('position-label').textContent = 'x:';
            } else if (mode === 'acceleration') {
                elements.mainTitle.textContent = '加速度';
                document.getElementById('position-label').textContent = 'y:';
            }

            updateAll();
        }
        
        // 加速度モードの区間追加・削除
        function addAccelerationPoint(t = '', v = '') {
            const pointCount = elements.accelerationPoints.children.length;
            const newPoint = document.createElement('div');
            newPoint.className = 'flex items-center justify-center gap-2';
            newPoint.innerHTML = `
                <label class="font-medium">t=${pointCount}:</label>
                <input type="number" value="${t}" placeholder="時間(s)" class="param-input t-input">
                <label class="font-medium">v=${pointCount}:</label>
                <input type="number" value="${v}" placeholder="速度(m/s)" class="param-input v-input">
                <div class="w-32 text-left" id="acc-display-${pointCount}"></div>
            `;
            elements.accelerationPoints.appendChild(newPoint);
            newPoint.querySelectorAll('input').forEach(input => input.addEventListener('input', updateAll));
        }
        elements.addPointBtn.addEventListener('click', () => {
            addAccelerationPoint();
            updateAll();
        });
        elements.removePointBtn.addEventListener('click', () => {
            if (elements.accelerationPoints.children.length > 2) {
                elements.accelerationPoints.lastChild.remove();
                updateAll();
            }
        });


        function getAcceleration(t, points) {
            if (currentMode === 'acceleration') {
                if (!points || points.length < 2) return 0;
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i+1];
                    if (t >= p1.t && t < p2.t) {
                        const dt = p2.t - p1.t;
                        return dt === 0 ? 0 : (p2.v - p1.v) / dt;
                    }
                }
                const p1 = points[points.length - 2];
                const p2 = points[points.length - 1];
                if (!p1 || !p2) return 0;
                const dt = p2.t - p1.t;
                return dt === 0 ? 0 : (p2.v - p1.v) / dt;
            }
            // 他のモードの加速度計算
            switch (currentMode) {
                case 'freeFall': case 'verticalThrowDown': case 'horizontalProjectile': return parseFloat(elements.inputs.gravity.value) || 9.8;
                case 'verticalThrowUp': case 'projectile': return -(parseFloat(elements.inputs.gravity.value) || 9.8);
                case 'uniform': return parseFloat(elements.inputs.accelerationUniform.value) || 0;
                default: return 0;
            }
        }

        function updateAll() {
            updateGraphs();
            updateCalculator();
        }

        function updateGraphs() {
            if (graph1Instance) graph1Instance.destroy();
            if (graph2Instance) graph2Instance.destroy();
            if (graph3Instance) graph3Instance.destroy();

            if (currentMode === 'acceleration') {
                const points = Array.from(elements.accelerationPoints.children).map(p => ({
                    t: parseFloat(p.querySelector('.t-input').value) || 0,
                    v: parseFloat(p.querySelector('.v-input').value) || 0,
                })).sort((a, b) => a.t - b.t);

                if (points.length < 2) return;
                const tMax = points[points.length - 1].t;
                elements.inputs.timeSlider.max = tMax;

                const labels = [], posData = [], velData = [], accData = [];
                let accumulatedPos = 0;
                const annotations = {};
                
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i+1];
                    const a = getAcceleration(p1.t, points);
                    
                    const accDisplay = document.getElementById(`acc-display-${i}`);
                    if (accDisplay) {
                        accDisplay.innerHTML = `a = <span class="font-bold">${a.toFixed(2)}</span> m/s²`;
                    }
                    
                    annotations[`line${i}`] = {
                        type: 'line',
                        xMin: p1.t,
                        xMax: p1.t,
                        borderColor: 'rgba(156, 163, 175, 0.5)',
                        borderWidth: 2,
                        borderDash: [6, 6]
                    };
                    
                    for (let t = p1.t; t < p2.t; t += timeStep) {
                        labels.push(t);
                        const dt = t - p1.t;
                        const v = p1.v + a * dt;
                        velData.push(v);
                        posData.push(accumulatedPos + p1.v * dt + 0.5 * a * dt * dt);
                        accData.push(a);
                    }
                    const segmentDt = p2.t - p1.t;
                    accumulatedPos += p1.v * segmentDt + 0.5 * a * segmentDt * segmentDt;
                }
                
                const lastPoint = points[points.length - 1];
                labels.push(lastPoint.t);
                velData.push(lastPoint.v);
                posData.push(accumulatedPos);
                accData.push(accData[accData.length - 1] || 0);
                annotations[`line${points.length - 1}`] = { type: 'line', xMin: lastPoint.t, xMax: lastPoint.t, borderColor: 'rgba(156, 163, 175, 0.5)', borderWidth: 2, borderDash: [6, 6] };
                const lastAccDisplay = document.getElementById(`acc-display-${points.length - 1}`);
                if (lastAccDisplay) lastAccDisplay.innerHTML = '';


                graph1Instance = createChart(elements.contexts.graph1, '変位 y-t', labels, posData, 'rgba(59, 130, 246, 1)', 'line', annotations);
                graph2Instance = createChart(elements.contexts.graph2, '速度 v-t', labels, velData, 'rgba(239, 68, 68, 1)', 'line', annotations);
                graph3Instance = createChart(elements.contexts.graph3, '加速度 a-t', labels, accData, 'rgba(16, 185, 129, 1)', 'line', annotations);

            } else {
                // 他のモードのグラフ描画ロジック
                const v0 = parseFloat(elements.inputs.initialVelocity.value) || 0;
                const tMax = parseFloat(elements.inputs.maxTime.value) || 10;
                const a = getAcceleration();
                elements.inputs.timeSlider.max = tMax;

                if (currentMode === 'horizontalProjectile' || currentMode === 'projectile') {
                    const angleRad = (currentMode === 'projectile') ? (parseFloat(elements.inputs.angle.value) || 0) * Math.PI / 180 : 0;
                    const v0x = v0 * Math.cos(angleRad);
                    const v0y = v0 * Math.sin(angleRad);
                    const g = Math.abs(a); 

                    const labels = [], xData = [], yData = [];
                    for (let t = 0; t <= tMax; t += timeStep) {
                        labels.push(t);
                        xData.push(v0x * t);
                        yData.push(v0y * t - 0.5 * g * t * t);
                    }
                    graph1Instance = createChart(elements.contexts.graph1, '軌道 y-x', xData, yData, 'rgba(16, 185, 129, 1)', 'scatter');
                    graph2Instance = createChart(elements.contexts.graph2, '水平位置 x-t', labels, xData, 'rgba(59, 130, 246, 1)');
                    graph3Instance = createChart(elements.contexts.graph3, '垂直位置 y-t', labels, yData, 'rgba(239, 68, 68, 1)');

                } else {
                    const labels = [], posData = [], velData = [], accData = [];
                    for (let t = 0; t <= tMax; t += timeStep) {
                        labels.push(t);
                        posData.push(v0 * t + 0.5 * a * t * t);
                        velData.push(v0 + a * t);
                        accData.push(a);
                    }
                    const posTitle = (currentMode === 'uniform') ? '位置 x-t' : '変位 y-t';
                    graph1Instance = createChart(elements.contexts.graph1, posTitle, labels, posData, 'rgba(59, 130, 246, 1)');
                    graph2Instance = createChart(elements.contexts.graph2, '速度 v-t', labels, velData, 'rgba(239, 68, 68, 1)');
                    graph3Instance = createChart(elements.contexts.graph3, '加速度 a-t', labels, accData, 'rgba(16, 185, 129, 1)');
                }
            }
        }

        function createChart(ctx, title, labels, data, color, type = 'line', annotations = {}) {
            const chartData = (type === 'scatter') ? data.map((val, i) => ({x: labels[i], y: val})) : data;
            return new Chart(ctx, {
                type: type,
                data: {
                    labels: (type === 'line') ? labels : null,
                    datasets: [{ data: chartData, borderColor: color, borderWidth: 2.5, fill: false, pointRadius: 0, tension: 0.1, showLine: true }, { data: [], borderColor: color, backgroundColor: 'white', pointRadius: 6, pointBorderWidth: 3, showLine: false }]
                },
                options: getChartOptions(title, type, annotations)
            });
        }
        
        function updateCalculator() {
            const t_slider = parseFloat(elements.inputs.timeSlider.value);
            document.getElementById('timeValue').textContent = `${t_slider.toFixed(1)} s`;

            if (currentMode === 'acceleration') {
                const points = Array.from(elements.accelerationPoints.children).map(p => ({
                    t: parseFloat(p.querySelector('.t-input').value) || 0,
                    v: parseFloat(p.querySelector('.v-input').value) || 0,
                })).sort((a, b) => a.t - b.t);
                if (points.length < 2) return;

                let accumulatedPos = 0;
                let finalVel = points[0].v;
                let finalAcc = getAcceleration(0, points);

                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i+1];
                    const a = getAcceleration(p1.t, points);
                    
                    if (t_slider > p2.t) {
                        const segmentDt = p2.t - p1.t;
                        accumulatedPos += p1.v * segmentDt + 0.5 * a * segmentDt * segmentDt;
                    } else if (t_slider >= p1.t) {
                        const timeInSegment = t_slider - p1.t;
                        accumulatedPos += p1.v * timeInSegment + 0.5 * a * timeInSegment * timeInSegment;
                        finalVel = p1.v + a * timeInSegment;
                        finalAcc = a;
                        break; 
                    }
                }
                
                document.getElementById('positionValue').textContent = accumulatedPos.toFixed(2);
                document.getElementById('velocityValue').textContent = finalVel.toFixed(2);
                updateTrackerPoint(t_slider, accumulatedPos, finalVel, finalAcc);

            } else if (currentMode === 'horizontalProjectile' || currentMode === 'projectile') {
                const v0 = parseFloat(elements.inputs.initialVelocity.value) || 0;
                const a = getAcceleration();
                const angleRad = (currentMode === 'projectile') ? (parseFloat(elements.inputs.angle.value) || 0) * Math.PI / 180 : 0;
                const v0x = v0 * Math.cos(angleRad);
                const v0y = v0 * Math.sin(angleRad);
                const g = Math.abs(a);
                const x = v0x * t_slider;
                const y = v0y * t_slider - 0.5 * g * t_slider * t_slider;
                const vx = v0x;
                const vy = v0y - g * t_slider;
                document.getElementById('positionX').textContent = x.toFixed(2);
                document.getElementById('positionY').textContent = y.toFixed(2);
                document.getElementById('velocityX').textContent = vx.toFixed(2);
                document.getElementById('velocityY').textContent = vy.toFixed(2);
                updateTrackerPoint(t_slider, {x, y});
            } else {
                const v0 = parseFloat(elements.inputs.initialVelocity.value) || 0;
                const a = getAcceleration();
                const pos = v0 * t_slider + 0.5 * a * t_slider * t_slider;
                const vel = v0 + a * t_slider;
                document.getElementById('positionValue').textContent = pos.toFixed(2);
                document.getElementById('velocityValue').textContent = vel.toFixed(2);
                updateTrackerPoint(t_slider, pos, vel, a);
            }
        }

        function updateTrackerPoint(t, pos, vel, acc) {
            if (currentMode === 'horizontalProjectile' || currentMode === 'projectile') {
                if (graph1Instance) { graph1Instance.data.datasets[1].data = [{x: pos.x, y: pos.y}]; graph1Instance.update('none'); }
                if (graph2Instance) { graph2Instance.data.datasets[1].data = [{x: t, y: pos.x}]; graph2Instance.update('none'); }
                if (graph3Instance) { graph3Instance.data.datasets[1].data = [{x: t, y: pos.y}]; graph3Instance.update('none'); }
            } else {
                if (graph1Instance) { graph1Instance.data.datasets[1].data = [{x: t, y: pos}]; graph1Instance.update('none'); }
                if (graph2Instance) { graph2Instance.data.datasets[1].data = [{x: t, y: vel}]; graph2Instance.update('none'); }
                if (graph3Instance) { graph3Instance.data.datasets[1].data = [{x: t, y: acc}]; graph3Instance.update('none'); }
            }
        }

        function getChartOptions(title, type, annotations = {}) {
            const [yLabel] = title.split(' ');
            const isScatter = type === 'scatter';
            const xUnit = isScatter ? 'm' : 's';
            const yUnit = yLabel.startsWith('位置') || yLabel.startsWith('変位') || yLabel.startsWith('軌道') ? 'm' : (yLabel === '速度' ? 'm/s' : 'm/s²');
            return {
                responsive: true, maintainAspectRatio: true,
                scales: {
                    x: { type: 'linear', title: { display: true, text: `${isScatter ? '水平位置' : '時間'} (${xUnit})` } },
                    y: { title: { display: true, text: `${isScatter ? '垂直位置' : yLabel} (${yUnit})` } }
                },
                plugins: { 
                    legend: { display: false }, 
                    title: { display: true, text: title, font: { size: 18 } },
                    annotation: { annotations: annotations }
                },
                interaction: { intersect: false, mode: 'index' },
            };
        }

        // イベントリスナー
        Object.keys(elements.buttons).forEach(key => {
            const mode = key.replace('btn', '').charAt(0).toLowerCase() + key.replace('btn', '').slice(1);
            elements.buttons[key].addEventListener('click', () => setMode(mode));
        });
        
        Object.values(elements.inputs).forEach(input => {
            if (input.type !== 'range') input.addEventListener('input', updateAll);
        });
        elements.inputs.timeSlider.addEventListener('input', updateCalculator);

        // 初期化
        window.onload = () => {
            addAccelerationPoint(0, 0);
            addAccelerationPoint(2, 10);
            addAccelerationPoint(4, 5);
            setMode('freeFall');
        };
    </script>
</body>
</html>